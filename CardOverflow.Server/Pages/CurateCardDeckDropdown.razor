@using Microsoft.FSharp.Core
@using CardOverflow.Entity
@using CardOverflow.Debug
@using CardOverflow.Pure
@using CardOverflow.Api
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Identity
@using CardOverflow.Sanitation
@inject IToastService ToastService
@inherits OwningComponentBase<CardOverflowDb>

<style>
  .dropdown-content {
    display: none;
    position: absolute;
    z-index: 1;
  }

  .dropdown:hover .dropdown-content {
    display: block;
  }
</style>

<div class="dropdown">
  <span class="btn btn-primary">
    Deck
  </span>
  <div class="dropdown-content card p-2" style="min-width: 20rem;">
    @foreach (var deck in decks) {
      <div class="d-flex justify-content-between">
        <button @onclick=@(() => new SearchCommand(deck.Query).Apply(DeckClicked.InvokeAsync)) class="btn btn-light">@deck.Name</button>
        <button @onclick=@(() => Edit(deck)) class="oi oi-pencil btn btn-light"></button>
      </div>
    }
    <button class="btn btn-success float-right mt-2" @onclick=@Create>
      Create
    </button>
  </div>
</div>

<BSModal @ref=Modal>
  <EditForm Model=ActiveDeck OnValidSubmit=Save>
    <BSModalHeader OnClick=Modal.Hide>
      @if (ActiveDeck.Id == 0) {
        <span>Create a new deck</span>
      } else {
        <span>Edit deck</span>
      }
    </BSModalHeader>
    <BSModalBody>
      <div class="form-group">
        <label for="newDeckNameInput">Name</label>
        <InputText @bind-Value=ActiveDeck.Name class="form-control" id="newDeckNameInput" /> @*this seems to break validation: @bind-Value:event="oninput"*@
        <ValidationMessage For=@(() => ActiveDeck.Name) />
      </div>
      <div class="form-group">
        <label for="newDeckQueryInput">Query</label>
        <InputText @bind-Value=ActiveDeck.Query class="form-control" id="newDeckQueryInput" /> @*this seems to break validation: @bind-Value:event="oninput"*@
        <ValidationMessage For=@(() => ActiveDeck.Query) />
      </div>
      <DataAnnotationsValidator />
    </BSModalBody>
    <BSModalFooter Class="d-flex justify-content-between">
      <BSButton Color="Color.Danger" OnClick=@Delete type="button">
        <span class="oi oi-trash"></span>
      </BSButton>
      <div>
        <BSButton Color="Color.Secondary" OnClick=Modal.Hide type="button">
          Cancel
        </BSButton>
        <BSButton Color="Color.Primary" type="submit">
          Save
        </BSButton>
      </div>
    </BSModalFooter>
  </EditForm>
</BSModal>

@code {
  BSModal Modal;
  [CascadingParameter]
  UserEntity User { get; set; }
  [Parameter]
  public string Query { get; set; }
  [Parameter]
  public EventCallback<SearchCommand> DeckClicked { get; set; }
  List<ViewDeck> decks = new List<ViewDeck>();
  ViewDeck ActiveDeck = new ViewDeck();

  protected override async Task OnInitializedAsync() {
    decks = await SanitizeDeckRepository.Get(Service, User?.Id ?? 0);
  }

  async Task Save() {
    var newId = await SanitizeDeckRepository.UpsertAsync(Service, ActiveDeck);
    if (ActiveDeck.Id == 0) {
      ActiveDeck.Id = newId;
      decks.Add(ActiveDeck);
    }
    Modal.Hide();
  }

  async Task Delete() {
    decks.Remove(ActiveDeck);
    var x = SanitizeDeckRepository.Delete(Service, User.Id, ActiveDeck);
    if (x.IsOk) {
      await x.ResultValue;
    } else {
      ToastService.ShowError(x.ErrorValue);
    }
    Modal.Hide();
  }

  void Create() {
    ActiveDeck = new ViewDeck(0, User.Id, "New Deck", Query);
    Modal.Show();
  }

  Task Edit(ViewDeck deck) {
    ActiveDeck = deck;
    Modal.Show();
    return DeckClicked.InvokeAsync(new SearchCommand(deck.Query));
  }

}
