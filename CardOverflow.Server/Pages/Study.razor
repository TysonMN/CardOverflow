@page "/study"
@using Microsoft.FSharp.Core
@using CardOverflow.Entity
@using CardOverflow.Debug
@using CardOverflow.Pure
@using CardOverflow.Api
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Identity
@using CardOverflow.Sanitation
@inherits OwningComponentBase<CardOverflowDb>
@inject Scheduler Scheduler
@inject TimeProvider TimeProvider
@inject IJSRuntime Js

@if (User == null) {
  <p><em>You aren't signed in dude.</em></p>
} else if (todaysCards == null) {
  <p><em>Loading...</em></p>
} else {
  <div class="study-content">
    @if (error == null) {
      @* https://stackoverflow.com/questions/19739001/which-is-the-difference-between-srcdoc-and-src-datatext-html-in-an/ *@
      <iframe sandbox allow-scripts class="study-iframe" srcdoc="@iframeSrcdoc"></iframe>
    } else {
      <h2>Error!</h2>
      <p>@error</p>
      <p>If you're seeing this error message, please contact support with the error message to resolve this issue.</p> @*lowTODO show a better error message*@
    }
  </div>
  <div class="study-footer">
    @if (isFront == true) {
      <button class="btn btn-primary" @onclick="@ShowBack">Show answer</button>
    } else if (isFront == false) {
      <button class="btn btn-primary" @onclick="@(() => SaveScore(Score.Again))">Again</button> @*medTODO show how long until this card comes back*@
      <button class="btn btn-primary" @onclick="@(() => SaveScore(Score.Hard))">Hard</button>
      <button class="btn btn-primary" @onclick="@(() => SaveScore(Score.Good))">Good</button>
      <button class="btn btn-primary" @onclick="@(() => SaveScore(Score.Easy))">Easy</button>
    } else {
      <button class="btn btn-primary" @onclick="@ShowNextCard">Show next card</button>
    }
    @if (isBlindMode) {
      <button class="btn btn-primary" @onclick="@DisableBlindMode">Disable blind mode</button>
      @transcript
    } else {
      <button class="btn btn-primary" @onclick="@EnableBlindMode">Enable blind mode</button>
    }
  </div>
}

@code {
  string iframeSrcdoc;
  string error;
  bool? isFront;
  [CascadingParameter]
  UserEntity User { get; set; }
  IList<FSharpResult<QuizCard, string>> todaysCards;
  DateTime frontVisible;
  string transcript;
  bool isBlindMode;

  protected override async Task OnInitializedAsync() {
    if (User != null) {
      todaysCards = (await CardRepository.GetTodaysCards(Service, User.Id)).ToList();
      ShowFront();
    }
  }

  async Task SaveScore(Score score) {
    var (interval, easeFactor) = Scheduler.interval(todaysCards.First().ResultValue, score);
    await SanitizeHistoryRepository.AddAndSaveAsync(Service, todaysCards.First().ResultValue.AcquiredCardId, score, TimeProvider.utcNow, interval, easeFactor, TimeProvider.utcNow - frontVisible);
    // medTODO also need to update the AcquiredCard with the new interval (and maybe other stuff), due to a denormalized db. Move the Scheduler to that new function
    // medTODO needs `undo review` support
    todaysCards.RemoveAt(0);
    ShowFront();
  }

  void ShowFront() {
    frontVisible = TimeProvider.utcNow;
    if (todaysCards.First().IsOk) {
      isFront = true;
      iframeSrcdoc = todaysCards.First().ResultValue.Front;
    } else {
      error = todaysCards.First().ErrorValue;
    }
    StateHasChanged();
  }

  void ShowBack() {
    isFront = false;
    iframeSrcdoc = todaysCards.First().ResultValue.Back;
    StateHasChanged();
  }

  void ShowNextCard() {
    todaysCards.RemoveAt(0);
    ShowFront();
    error = null;
  }

  async Task EnableBlindMode() {
    await Js.InvokeAsync<object>("Listen", DotNetObjectReference.Create(this));
    isBlindMode = true;
    await Speak(todaysCards.First().ResultValue.FrontSynthVoice);
  }

  async Task Speak(string msg) =>
    await Js.InvokeAsync<object>("Speak", msg);

  async Task DisableBlindMode() {
    await Js.InvokeAsync<object>("StopListening", DotNetObjectReference.Create(this));
    isBlindMode = false;
  }

  [JSInvokable]
  public async Task<string> GetTranscript(string rawTranscript) {
    this.transcript = rawTranscript.Trim().ToLower();
    Console.WriteLine(this.transcript);
    StateHasChanged();
    switch (this.transcript) {
      case "what":
        if (isFront == true) {
          await Speak(todaysCards.First().ResultValue.FrontSynthVoice);
        } else {
          await Speak(todaysCards.First().ResultValue.BackSynthVoice);
        }
        break;
      case "tell me":
        ShowBack();
        await Speak(todaysCards.First().ResultValue.BackSynthVoice);
        break;
      case "again":
        await SaveScore(Score.Again);
        await Speak(todaysCards.First().ResultValue.FrontSynthVoice);
        break;
      case "hard":
        await SaveScore(Score.Hard);
        await Speak(todaysCards.First().ResultValue.FrontSynthVoice);
        break;
      case "good":
        await SaveScore(Score.Good);
        await Speak(todaysCards.First().ResultValue.FrontSynthVoice);
        break;
      case "easy":
        await SaveScore(Score.Easy);
        await Speak(todaysCards.First().ResultValue.FrontSynthVoice);
        break;
      default:
        break;
    }
    return "C# received: " + this.transcript;
  }

}
