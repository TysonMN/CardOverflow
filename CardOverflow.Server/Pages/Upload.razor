@page "/upload"

@using CardOverflow.Sanitation
@using CardOverflow.Entity
@using System.IO
@using Blazor.FileReader
@inject IFileReaderService fileReaderService
@inherits OwningComponentBase<CardOverflowDb>
<style>
  .droptarget {
    display: block;
    padding: 20px;
    margin-bottom: 10px;
    border: 1px dashed black;
    border-radius: 5px;
  }

  .droptarget-drag {
    border-color: orangered;
    font-weight: bold;
  }
</style>
<h1>Anki Importer</h1>
<div class="@DropClass"
     @ref="@dropTargetElement"
     @ondrop="@OnDrop"
     @ondragenter="@(e => this.DropClass += " droptarget-drag")"
     @ondragleave="@(e => this.DropClass = _dropClass)">
  Drop Anki exports here (*.colpkg or *.apkg)
  @foreach (var fileInfo in FileList) {
    <br />@fileInfo.Name
  }
</div>
<button @onclick="@ReadFile" class="btn btn-primary">Import</button>
<button @onclick="@ClearFile" class="btn btn-primary">Clear</button>

<textarea style="max-width: 100%;" cols="50" rows="20">@Output</textarea>

@code {
  ElementReference dropTargetElement;
  IFileReaderRef dropReference;
  [CascadingParameter]
  UserEntity User { get; set; }

  const string _dropClass = "droptarget";
  string DropClass { get; set; } = _dropClass;
  string Output { get; set; }
  List<IFileInfo> FileList { get; } = new List<IFileInfo>();

  protected override async Task OnAfterRenderAsync(bool firstRender) {
    dropReference = fileReaderService.CreateReference(dropTargetElement);
    await dropReference.RegisterDropEventsAsync();
  }

  public async Task ClearFile() {
    await dropReference.ClearValue();
    await this.RefreshFileList();
  }

  public async Task OnDrop(DragEventArgs e) {
    Output += "Dropped a file.";
    this.DropClass = _dropClass;
    this.StateHasChanged();
    await this.RefreshFileList();
  }

  private async Task RefreshFileList() {
    this.FileList.Clear();
    foreach (var file in await dropReference.EnumerateFilesAsync()) {
      var fileInfo = await file.ReadFileInfoAsync();
      this.FileList.Add(fileInfo);
    }
    this.StateHasChanged();
  }

  public async Task ReadFile() {
    Output = string.Empty;
    this.StateHasChanged();
    var nl = Environment.NewLine;
    foreach (var file in await dropReference.EnumerateFilesAsync()) {
      var fileInfo = await file.ReadFileInfoAsync();
      Output += $"{nameof(IFileInfo)}.{nameof(fileInfo.Name)}: {fileInfo.Name}{nl}";
      Output += $"{nameof(IFileInfo)}.{nameof(fileInfo.Size)}: {fileInfo.Size}{nl}";
      Output += $"{nameof(IFileInfo)}.{nameof(fileInfo.Type)}: {fileInfo.Type}{nl}";
      Output += $"{nameof(IFileInfo)}.{nameof(fileInfo.LastModifiedDate)}: {fileInfo.LastModifiedDate?.ToString() ?? "(N/A)"}{nl}";
      Output += $"Uploading...";
      this.StateHasChanged();

      var downloadPath = SanitizeAnki.ankiExportsDir + "/" + fileInfo.Name + CardOverflow.Pure.Random.cryptographicString(32);
      var buffer = new byte[4096];
      var count = 0;
      using (var stream = await file.OpenReadAsync()) {
        using (var fileStream = new FileStream(downloadPath, FileMode.Create, FileAccess.Write)) {
          while ((count = await stream.ReadAsync(buffer, 0, buffer.Length)) > 0) {
            Output += $"Read {count} bytes. {stream.Position} / {stream.Length}{nl}";
            this.StateHasChanged();
            await fileStream.WriteAsync(buffer, 0, count);
          }
        }
      }
      Output += $"Done uploading {fileInfo.Name}!{nl}";
      Output += $"Beginning import... this  may take a while.{nl}";
      this.StateHasChanged();

      var x = SanitizeAnki.Import(Service, downloadPath, User.Id);
      if (x.IsOk) {
        Output += $"Import complete!.{nl}";
      } else {
        Output += $"Error(s) importing: " + x.ErrorValue;
      }
      this.StateHasChanged();
    }

  }
}